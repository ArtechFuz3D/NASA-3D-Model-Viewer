<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NASA 3D Hologram Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
    canvas.webgl { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: block; }
    #ui {
      position: fixed; top: 1.5rem; left: 50%; transform: translateX(-50%);
      z-index: 10; display: flex; flex-direction: column; align-items: center; gap: 0.5rem;
    }
    h1 { color: #70c1ff; font-size: 0.75rem; letter-spacing: 0.3em; text-transform: uppercase; text-shadow: 0 0 12px #70c1ff88; }
    #modelSelect {
      background: rgba(0,10,30,0.85); border: 1px solid #70c1ff55;
      color: #70c1ff; font-family: 'Courier New', monospace; font-size: 0.8rem;
      padding: 0.4rem 0.8rem; border-radius: 3px; outline: none; cursor: pointer;
      max-width: 420px; width: 90vw;
      box-shadow: 0 0 20px #70c1ff22, inset 0 0 10px #70c1ff11;
    }
    #modelSelect option { background: #000d1a; color: #70c1ff; }
    #status { color: #70c1ff88; font-size: 0.65rem; letter-spacing: 0.15em; min-height: 1em; }
    body::after {
      content: ''; position: fixed; inset: 0; pointer-events: none; z-index: 5;
      background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.07) 2px, rgba(0,0,0,0.07) 4px);
    }
    body::before { content: ''; position: fixed; inset: 1rem; border: 1px solid #70c1ff15; pointer-events: none; z-index: 6; }
  </style>

  <!--
    Import map: tells the browser how to resolve bare specifiers like "three"
    and "three/addons/..." without a bundler. This is the official Three.js
    recommended approach for static sites and GitHub Pages.
    See: https://threejs.org/docs/#manual/en/introduction/Installation
  -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="ui">
    <h1>NASA 3D Hologram Viewer</h1>
    <select id="modelSelect"><option value="">Fetching NASA models…</option></select>
    <div id="status"></div>
  </div>
  <canvas class="webgl"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader }    from 'three/addons/loaders/GLTFLoader.js';
    import { STLLoader }     from 'three/addons/loaders/STLLoader.js';
    import { TDSLoader }     from 'three/addons/loaders/TDSLoader.js';
    import { OBJLoader }     from 'three/addons/loaders/OBJLoader.js';

    /* ── Shaders (inline — no file fetching needed) ── */
    const vertexShader = `
      uniform float uTime;
      varying vec3 vNormal;
      varying vec3 vPos;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vPos    = position;
        vec3 p  = position + normal * sin(uTime * 2.0 + position.y * 10.0) * 0.002;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
      }
    `;
    const fragmentShader = `
      uniform float uTime;
      uniform vec3  uColor;
      varying vec3  vNormal;
      varying vec3  vPos;
      void main() {
        float scan    = sin(vPos.y * 80.0 + uTime * 3.0) * 0.5 + 0.5;
        float fresnel = pow(1.0 - abs(dot(normalize(vNormal), vec3(0.0,0.0,1.0))), 2.0);
        float alpha   = (scan * 0.4 + fresnel * 0.6) * 0.85;
        gl_FragColor  = vec4(uColor, alpha);
      }
    `;

    /* ── Scene ── */
    const canvas   = document.querySelector('.webgl');
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.01, 1000);
    camera.position.set(5, 3, 5);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping  = true;
    controls.dampingFactor  = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance    = 1;
    controls.maxDistance    = 25;
    controls.zoomSpeed      = 1.5;
    controls.rotateSpeed    = 0.6;
    controls.panSpeed       = 0.8;

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* ── Hologram material ── */
    const material = new THREE.ShaderMaterial({
      vertexShader, fragmentShader,
      uniforms: {
        uTime:  { value: 0 },
        uColor: { value: new THREE.Color('#70c1ff') }
      },
      transparent: true,
      wireframe:   true,
      depthWrite:  false,
      blending:    THREE.AdditiveBlending,
      side:        THREE.DoubleSide
    });

    /* ── Model helpers ── */
    const statusEl = document.getElementById('status');
    const setStatus = msg => statusEl.textContent = msg;

    let current = null;

    function dispose() {
      if (!current) return;
      scene.remove(current);
      current.traverse(o => o.geometry?.dispose());
      current = null;
    }

    function applyMat(obj) {
      obj.traverse(c => { if (c.isMesh) c.material = material; });
    }

    function fitToView(obj) {
      const box  = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const max  = Math.max(size.x, size.y, size.z) || 1;
      obj.scale.setScalar(3 / max);
      const center = box.getCenter(new THREE.Vector3());
      obj.position.sub(center.multiplyScalar(3 / max));
    }

    function loadModel(url) {
      dispose();
      setStatus('Loading…');
      const ext = url.split('?')[0].split('.').pop().toLowerCase();

      const onProgress = xhr => {
        if (xhr.total) setStatus(`Loading… ${Math.round(xhr.loaded / xhr.total * 100)}%`);
      };
      const onError = err => {
        console.error(err);
        setStatus('Error loading model (CORS or unsupported format)');
      };
      const place = obj => {
        current = obj;
        applyMat(current);
        fitToView(current);
        scene.add(current);
        // Reset camera so model is always in view after switching
        camera.position.set(5, 3, 5);
        controls.target.set(0, 0, 0);
        controls.update();
        setStatus('');
      };

      if (ext === 'glb' || ext === 'gltf') {
        new GLTFLoader().load(url, d => place(d.scene), onProgress, onError);
      } else if (ext === 'stl') {
        new STLLoader().load(url, geo => place(new THREE.Mesh(geo, material)), onProgress, onError);
      } else if (ext === '3ds') {
        new TDSLoader().load(url, place, onProgress, onError);
      } else if (ext === 'obj') {
        new OBJLoader().load(url, place, onProgress, onError);
      } else {
        setStatus(`Unsupported format: .${ext}`);
      }
    }

    /* ── Dropdown population ── */
    const select   = document.getElementById('modelSelect');
    const BASE     = 'https://raw.githubusercontent.com/nasa/NASA-3D-Resources/master/';
    const EXTS     = ['glb','gltf','stl','obj','3ds'];

    const CURATED = [
      { name: 'Curiosity Rover',             path: 'Models/Curiosity/MSL_Rover.STL' },
      { name: 'Hubble Space Telescope',       path: 'Models/Hubble_Space_Telescope/hubble_space_telescope_2002.3ds' },
      { name: 'Mars Pathfinder Lander',       path: 'Models/Mars_Pathfinder_Lander/mars_pathfinder_lander.3ds' },
      { name: 'Voyager Spacecraft',           path: 'Models/Voyager/voyager.3ds' },
      { name: 'Cassini',                      path: 'Models/Cassini/cassini.3ds' },
      { name: 'New Horizons',                 path: 'Models/New_Horizons/new_horizons.3ds' },
      { name: 'Dawn Spacecraft',              path: 'Models/Dawn/dawn.3ds' },
      { name: 'Space Shuttle',                path: 'Models/Space_Shuttle/space_shuttle.3ds' },
      { name: 'Apollo 11 Command Module',     path: 'Models/Apollo_11_Command_Module/command_module.3ds' },
      { name: 'Mars Reconnaissance Orbiter',  path: 'Models/Mars_Reconnaissance_Orbiter/mars_reconnaissance_orbiter.3ds' },
      { name: 'MAVEN',                        path: 'Models/MAVEN/maven.3ds' },
      { name: 'Juno',                         path: 'Models/Juno/juno.3ds' },
    ];

    function populate(models) {
      select.innerHTML = '<option value="">— Select a model —</option>';
      models.forEach(m => {
        const o = document.createElement('option');
        o.value = BASE + m.path;
        o.textContent = m.name || m.path.split('/').pop();
        select.appendChild(o);
      });
      setStatus(`${models.length} models available`);
    }

    async function fetchModels() {
      setStatus('Fetching model list…');
      try {
        const bRes = await fetch(
          'https://api.github.com/repos/nasa/NASA-3D-Resources/branches/master',
          { headers: { Accept: 'application/vnd.github+json' } }
        );
        if (!bRes.ok) throw new Error(`Branch API ${bRes.status}`);
        const branch = await bRes.json();
        const sha    = branch.commit.commit.tree.sha;

        const tRes = await fetch(
          `https://api.github.com/repos/nasa/NASA-3D-Resources/git/trees/${sha}?recursive=1`,
          { headers: { Accept: 'application/vnd.github+json' } }
        );
        if (!tRes.ok) throw new Error(`Tree API ${tRes.status}`);
        const tData = await tRes.json();

        const models = (tData.tree || [])
          .filter(f => f.type === 'blob' && EXTS.some(e => f.path.toLowerCase().endsWith('.' + e)))
          .map(f => ({ name: f.path.split('/').pop(), path: f.path }));

        if (!models.length) throw new Error('No models in tree');
        populate(models);
        if (tData.truncated) setStatus(`Tree truncated — ${models.length} models found`);
      } catch (err) {
        console.warn('GitHub API failed:', err.message);
        populate(CURATED);
        setStatus('API unavailable — showing curated list');
      }
    }

    fetchModels();
    select.addEventListener('change', e => { if (e.target.value) loadModel(e.target.value); });

    /* ── Render loop ── */
    const clock = new THREE.Clock();
    (function tick() {
      material.uniforms.uTime.value = clock.getElapsedTime();
      if (current) current.rotation.y += 0.003;
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>
